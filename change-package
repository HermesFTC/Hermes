#!/bin/zsh

# Working script to change root package name in a multi-module Kotlin project
# Usage: ./change-package <old-package> <new-package>
# Example: ./change-package com.example.something org.example.otherthing

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

print_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
print_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
print_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
print_error() { echo -e "${RED}[ERROR]${NC} $1"; }

if [[ $# -ne 2 ]]; then
    print_error "Usage: $0 <old-package> <new-package>"
    print_error "Example: $0 com.example.something org.example.differentthing"
    exit 1
fi

OLD_PACKAGE="$1"
NEW_PACKAGE="$2"
OLD_PATH="${OLD_PACKAGE//./\/}"
NEW_PATH="${NEW_PACKAGE//./\/}"

print_info "Changing package from '$OLD_PACKAGE' to '$NEW_PACKAGE'"
print_info "Directory path change: '$OLD_PATH' -> '$NEW_PATH'"

echo -n "This will modify many files and move directories. Continue? (y/N): "
read -r response
if [[ ! "$response" =~ ^[Yy]$ ]]; then
    print_info "Exiting..."
    exit 0
fi

BACKUP_SUFFIX=".backup-$(date +%Y%m%d-%H%M%S)"

# Function to update file contents
update_file_content() {
    local file="$1"

    # Skip binary files
    if ! file "$file" | grep -q "text"; then
        return 1
    fi

    # Create backup
    cp "$file" "$file$BACKUP_SUFFIX"

    # Use perl for more reliable regex replacement
    perl -i -pe "s/^package $OLD_PACKAGE\$/package $NEW_PACKAGE/g" "$file"
    perl -i -pe "s/^package $OLD_PACKAGE\./package $NEW_PACKAGE./g" "$file"
    perl -i -pe "s/import $OLD_PACKAGE\$/import $NEW_PACKAGE/g" "$file"
    perl -i -pe "s/import $OLD_PACKAGE\./import $NEW_PACKAGE./g" "$file"
    perl -i -pe "s/\"$OLD_PACKAGE\"/\"$NEW_PACKAGE\"/g" "$file"
    perl -i -pe "s/\"$OLD_PACKAGE\./\"$NEW_PACKAGE./g" "$file"
    perl -i -pe "s/'$OLD_PACKAGE'/'$NEW_PACKAGE'/g" "$file"
    perl -i -pe "s/'$OLD_PACKAGE\./'$NEW_PACKAGE./g" "$file"
    perl -i -pe "s/package=\"$OLD_PACKAGE\"/package=\"$NEW_PACKAGE\"/g" "$file"
    perl -i -pe "s/package=\"$OLD_PACKAGE\./package=\"$NEW_PACKAGE./g" "$file"
    perl -i -pe "s/android:name=\"$OLD_PACKAGE\./android:name=\"$NEW_PACKAGE./g" "$file"

    # Check if file actually changed
    if diff -q "$file" "$file$BACKUP_SUFFIX" > /dev/null 2>&1; then
        rm "$file$BACKUP_SUFFIX"
        return 1
    else
        print_success "Updated: $file"
        return 0
    fi
}

print_info "Step 1: Updating file contents..."

updated_files=0
FILE_PATTERNS=("*.kt" "*.java" "*.gradle" "*.gradle.kts" "*.xml" "*.pro" "*.properties" "*.json" "*.yml" "*.yaml" "*.kts")

for pattern in "${FILE_PATTERNS[@]}"; do
    print_info "Processing files matching: $pattern"

    find . -name "$pattern" -type f | while read -r file; do
        if [[ "$file" =~ (\.git/|build/|\.gradle/|\.idea/|node_modules/) ]]; then
            continue
        fi

        if grep -q "$OLD_PACKAGE" "$file" 2>/dev/null; then
            print_info "Found package reference in: $file"
            update_file_content "$file" && updated_files=$((updated_files + 1))
        fi
    done
done

print_info "Step 2: Moving directories..."

# Find all old package directories
print_info "Finding old package directories to move..."

find_old_dirs=()
while IFS= read -r dir; do
    find_old_dirs+=("$dir")
done < <(find . -type d -path "*/$OLD_PATH" -not -path "*/.git/*" -not -path "*/build/*" -not -path "*/.gradle/*" -not -path "*/.idea/*" -not -path "*/node_modules/*")

if [[ ${#find_old_dirs[@]} -eq 0 ]]; then
    print_warning "No directories found with the path: $OLD_PATH"
else
    print_info "Found ${#find_old_dirs[@]} old package directories to move."
fi

for old_dir in "${OLD_PACKAGE_DIRS[@]}"; do
    # Get the parent directory of the old package (e.g., 'src/main/java/com/acmerobotics')
    parent_dir="$(dirname "$old_dir")"

    # Construct the full path to the new directory by replacing the OLD_PATH with NEW_PATH
    # This is the most crucial part to get right.
    new_dir="${old_dir/$OLD_PATH/$NEW_PATH}"

    # If the target directory already exists, it's a merge operation.
    if [[ -d "$new_dir" ]]; then
        print_info "Target directory exists: $new_dir. Merging contents."

        # Move all contents from the old directory to the new one.
        mv "$old_dir"/* "$new_dir"/

        # Remove the now-empty old directory.
        rmdir "$old_dir"

    else
        # If the target directory does not exist, simply move and rename.
        print_info "Moving directory: $old_dir -> $new_dir"

        # Ensure the parent directories for the new path exist.
        mkdir -p "$(dirname "$new_dir")"

        # Perform the move operation.
        mv "$old_dir" "$new_dir"
    fi

    # Clean up empty parent directories after the move.
    current_dir="$(dirname "$old_dir")"
    while [[ "$current_dir" != "." && -d "$current_dir" ]]; do
        if rmdir "$current_dir" 2>/dev/null; then
            print_info "Removed empty directory: $current_dir"
            current_dir="$(dirname "$current_dir")"
        else
            break
        fi
    done
done

print_info "Step 3: Final verification..."

# Check for remaining old package references
remaining_refs=$(grep -r "$OLD_PACKAGE" . --exclude-dir=.git --exclude-dir=build --exclude-dir=.gradle --exclude-dir=.idea --exclude-dir=node_modules 2>/dev/null | wc -l | tr -d ' ')

if [[ $remaining_refs -gt 0 ]]; then
    print_warning "Found $remaining_refs remaining references to old package:"
    grep -r "$OLD_PACKAGE" . --exclude-dir=.git --exclude-dir=build --exclude-dir=.gradle --exclude-dir=.idea --exclude-dir=node_modules 2>/dev/null | head -10
else
    print_success "No remaining references found!"
fi

# Check directory structure
old_dirs=$(find . -type d -path "*/$OLD_PATH*" 2>/dev/null | grep -v -E "(\.git/|build/|\.gradle/|\.idea/|node_modules/)" | wc -l | tr -d ' ')
new_dirs=$(find . -type d -path "*/$NEW_PATH*" 2>/dev/null | grep -v -E "(\.git/|build/|\.gradle/|\.idea/|node_modules/)" | wc -l | tr -d ' ')

print_success "Package rename completed!"
print_info "Summary:"
print_info "  Old package: $OLD_PACKAGE"
print_info "  New package: $NEW_PACKAGE"
print_info "  Old package directories remaining: $old_dirs"
print_info "  New package directories created: $new_dirs"

if [[ $old_dirs -gt 0 ]]; then
    print_warning "Some old directories still exist:"
    find . -type d -path "*/$OLD_PATH*" 2>/dev/null | grep -v -E "(\.git/|build/|\.gradle/|\.idea/|node_modules/)" | head -5
fi

if [[ $new_dirs -gt 0 ]]; then
    print_success "New directories created:"
    find . -type d -path "*/$NEW_PATH*" 2>/dev/null | grep -v -E "(\.git/|build/|\.gradle/|\.idea/|node_modules/)" | head -5
fi

backup_count=$(find . -name "*$BACKUP_SUFFIX" 2>/dev/null | wc -l | tr -d ' ')
if [[ $backup_count -gt 0 ]]; then
    print_info "Backup files created: $backup_count (suffix: $BACKUP_SUFFIX)"
    print_warning "Remove backups with: find . -name '*$BACKUP_SUFFIX' -delete"
fi

print_warning "Next steps:"
print_warning "  1. Review changes: git diff"
print_warning "  2. Clean and rebuild project"
print_warning "  3. Test thoroughly"
print_warning "  4. Remove backup files when satisfied"